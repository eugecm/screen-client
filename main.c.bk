#define F_CPU 8000000UL

#include <alloca.h>
#include <avr/cpufunc.h>
#include <avr/io.h>
#include <util/delay.h>

void init(void);

char* RX_ADDRESS = "ABABA";

int main(void)
{
    char data;

    init();
    lcd_init();

    lcd_clear_and_home();

    // read STATUS
    data = nrf24_read_register(0x07);
    lcd_print_text("STATUS=");
    lcd_print_byte(data);

    lcd_move_second_line();

    // read CONFIG
    data = nrf24_read_register(0x00);
    lcd_print_text("CONFIG=");
    lcd_print_byte(data);

    // Making sure CE is low
    PORTB &= ~(1<<PB1);
    _delay_ms(1000);

    // Configure RX mode
    {
	// Make active RX (PRIM_RX=1), with CRC 1 byte
	nrf24_write_register(NRF24_REG_CONFIG, 0b00001011);

	// POWER DOWN to STANDBY takes 1.5ms
	_delay_ms(3);

	// Enable data pipe 0
	nrf24_write_register(NRF24_REG_EN_RXADDR, 0x01);

	// Disable auto acknowledgement on all pipes (for compatibility with NRF24)
	nrf24_write_register(NRF24_REG_EN_AA, 0x00);

	// Disable retransmissions
	nrf24_write_register(NRF24_REG_SETUP_RETR, 0x00);

	// Set 1mbps, -18dBm
	nrf24_write_register(NRF24_REG_RF_SETUP, 0b00000000);

	// Set 2416MHz
	nrf24_write_register(NRF24_REG_RF_CH, 0x10);

	// Disable features
	nrf24_write_register(NRF24_REG_FEATURE, 0x00);

	// Disable dynamic payload for everything
	nrf24_write_register(NRF24_REG_DYNPD, 0x00);

	// Set address length of 5 bytes
	nrf24_write_register(NRF24_REG_SETUP_AW, 0x03);

	// Set address
	nrf24_write_register_n(NRF24_REG_RX_ADDR_P0, RX_ADDRESS, 5);

	// Set payload width (32 bytes) (for compatibility with NRF24)
	nrf24_write_register(NRF24_REG_RX_PW_P0, 0b00100000);

	_delay_us(500);
	PORTB |= (1<<PB1);
	_delay_us(500);
    }

    lcd_show2("WAITING...");

    // Loop for a packet and display it
    // Receive loop:
    char status;
    char buf[32];
    while (1) {
	// poll RX_DR from STATUS (if high means data received)
	status = nrf24_read_register(NRF24_REG_STATUS);

	if ((status & 0x40) == 0) {
	    _delay_ms(1000);
	    continue;
	}

	// Wait and make CE low (to go to standby I)
	PORTB &= ~(1<<PB1);

	// Read the payload and display it
	nrf24_read_rx_payload(buf, 32);
	lcd_show2(buf);

	// clear the status
	nrf24_write_register(NRF24_REG_STATUS, (status | 0x20));

	// Go back to RX mode
	PORTB |= (1<<PB1);
	_delay_us(500);
    }

    return 1;
}

void init(void) {
    lcd_init();
    nrf24_init();

    /* Set unused ports as input with pull-up resistors */
    DDRC = 0; PORTC = 0xFF;

    /* NOP used for synchronization */
    _NOP();
}
